// Generated by CoffeeScript 1.9.1
(function() {
  var BH_SIZE, Particle, RAF, animate, bhImage, blackholes, bufferCanvas, bufferCtx, canvas, ctx, execAnimate, particles, target;

  canvas = document.getElementById('cas');

  ctx = canvas.getContext("2d");

  bufferCanvas = document.createElement("canvas");

  bufferCtx = bufferCanvas.getContext("2d");

  bufferCanvas.width = canvas.width = document.body.offsetWidth;

  bufferCanvas.height = canvas.height = document.body.offsetHeight;

  window.onresize = function() {
    bufferCanvas.width = canvas.width = document.body.offsetWidth;
    return bufferCanvas.height = canvas.height = document.body.offsetHeight;
  };

  RAF = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
      return window.setTimeout(callback, 1000 / 60);
    };
  })();

  Particle = (function() {
    function Particle(options) {
      this.x = options.x, this.y = options.y, this.r = options.r;
      this._init();
    }

    Particle.prototype._init = function() {
      this.vx = Math.random() * 4 - 2;
      this.vy = Math.random() * 4 - 2;
      this.ax = 0;
      return this.ay = 0;
    };

    Particle.prototype.move = function() {
      var maxSpeed;
      this.vx += this.ax;
      this.vy += this.ay;
      maxSpeed = 10;
      this.vx = Math.abs(this.vx) > maxSpeed ? maxSpeed * Math.abs(this.vx) / this.vx : this.vx;
      this.vy = Math.abs(this.vy) > maxSpeed ? maxSpeed * Math.abs(this.vy) / this.vy : this.vy;
      this.oldx = this.x;
      this.oldy = this.y;
      this.x += this.vx;
      return this.y += this.vy;
    };

    Particle.prototype.attract = function() {
      var angle, bh, cx, cy, dis, j, lax, lay, len, power, results;
      this.ax = this.ay = 0;
      results = [];
      for (j = 0, len = blackholes.length; j < len; j++) {
        bh = blackholes[j];
        cx = bh.x - this.x;
        cy = bh.y - this.y;
        angle = Math.atan(cx / cy);
        dis = Math.sqrt(cx * cx + cy * cy);
        power = bh.power * 0.1;
        lax = Math.abs(power * Math.sin(angle));
        lay = Math.abs(power * Math.cos(angle));
        this.ax += cx > 0 ? lax : -lax;
        results.push(this.ay += cy > 0 ? lay : -lay);
      }
      return results;
    };

    Particle.prototype.draw = function() {
      bufferCtx.save();
      bufferCtx.strokeStyle = "#FFF";
      bufferCtx.lineCap = bufferCtx.lineJoin = "round";
      bufferCtx.lineWidth = this.r;
      bufferCtx.beginPath();
      bufferCtx.moveTo(this.oldx - this.r, this.oldy - this.r);
      bufferCtx.lineTo(this.x - this.r, this.y - this.r);
      bufferCtx.stroke();
      return bufferCtx.restore();
    };

    return Particle;

  })();

  particles = [];

  blackholes = [];

  BH_SIZE = 20;

  bhImage = (function() {
    var bhCas, bhCtx, i, j, opacity;
    bhCas = document.createElement("canvas");
    bhCas.width = bhCas.height = BH_SIZE * 2;
    bhCtx = bhCas.getContext("2d");
    opacity = 0;
    for (i = j = 0; j < 20; i = ++j) {
      opacity += 0.05;
      bhCtx.beginPath();
      bhCtx.fillStyle = "rgba(188,186,187," + opacity + ")";
      bhCtx.arc(bhCas.width / 2, bhCas.height / 2, BH_SIZE - i, 0, Math.PI * 2);
      bhCtx.fill();
    }
    bhCtx.beginPath();
    bhCtx.fillStyle = "#000";
    bhCtx.arc(bhCas.width / 2, bhCas.height / 2, BH_SIZE - 5, 0, Math.PI * 2);
    bhCtx.fill();
    return bhCas;
  })();

  target = null;

  canvas.onmousedown = function(e) {
    var bh, cx, cy, i, j, len, x, y;
    x = e.clientX - this.offsetLeft;
    y = e.clientY - this.offsetTop;
    for (i = j = 0, len = blackholes.length; j < len; i = ++j) {
      bh = blackholes[i];
      cx = bh.x - x;
      cy = bh.y - y;
      if (cx * cx + cy * cy <= BH_SIZE * BH_SIZE) {
        target = bh;
        break;
      }
    }
    if (!target && e.button === 0) {
      return blackholes.push({
        x: x,
        y: y,
        r: BH_SIZE,
        power: 2
      });
    } else {
      if (e.button === 2) {
        return blackholes.splice(i, 1);
      }
    }
  };

  canvas.onmousemove = function(e) {
    var x, y;
    if (target) {
      x = e.clientX - this.offsetLeft;
      y = e.clientY - this.offsetTop;
      target.x = x;
      return target.y = y;
    }
  };

  canvas.onmouseup = canvas.onmouseout = function(e) {
    return target = null;
  };

  execAnimate = function() {
    var i, j;
    for (i = j = 1; j < 200; i = ++j) {
      particles.push(new Particle({
        x: canvas.width * Math.random(),
        y: canvas.height * Math.random(),
        r: 2
      }));
    }
    return animate();
  };

  animate = function() {
    var bh, j, k, len, len1, p;
    bufferCtx.save();
    bufferCtx.globalCompositeOperation = 'destination-out';
    bufferCtx.globalAlpha = 0.3;
    bufferCtx.fillRect(0, 0, canvas.width, canvas.height);
    bufferCtx.restore();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (j = 0, len = blackholes.length; j < len; j++) {
      bh = blackholes[j];
      ctx.drawImage(bhImage, bh.x - bh.r, bh.y - bh.r, bh.r * 2, bh.r * 2);
    }
    for (k = 0, len1 = particles.length; k < len1; k++) {
      p = particles[k];
      p.attract();
      p.move();
      p.draw();
    }
    ctx.drawImage(bufferCanvas, 0, 0);
    return RAF(animate);
  };

  execAnimate();

}).call(this);

//# sourceMappingURL=test.js.map
