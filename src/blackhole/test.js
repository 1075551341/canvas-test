// Generated by CoffeeScript 1.9.1
(function() {
  var BH_SIZE, BlackHole, Particle, RAF, animate, bhImage, blackholes, bufferCanvas, bufferCtx, canvas, ctx, execAnimate, particles, target;

  particles = [];

  blackholes = [];

  BH_SIZE = 15;

  canvas = document.getElementById('cas');

  ctx = canvas.getContext("2d");

  bufferCanvas = document.createElement("canvas");

  bufferCtx = bufferCanvas.getContext("2d");

  bufferCanvas.width = canvas.width = document.body.offsetWidth;

  bufferCanvas.height = canvas.height = document.body.offsetHeight;

  window.onresize = function() {
    bufferCanvas.width = canvas.width = document.body.offsetWidth;
    return bufferCanvas.height = canvas.height = document.body.offsetHeight;
  };

  RAF = (function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
      return window.setTimeout(callback, 1000 / 60);
    };
  })();

  Particle = (function() {
    function Particle(options) {
      this.x = options.x, this.y = options.y, this.r = options.r;
      this._init();
    }

    Particle.prototype._init = function() {
      this.vx = Math.random() * 4 - 2;
      this.vy = Math.random() * 4 - 2;
      this.ax = 0;
      return this.ay = 0;
    };

    Particle.prototype.move = function() {
      var maxSpeed, ref, ref1;
      this.vx += this.ax;
      this.vy += this.ay;
      maxSpeed = 10;
      this.vx = Math.abs(this.vx) > maxSpeed ? maxSpeed * Math.abs(this.vx) / this.vx : this.vx;
      this.vy = Math.abs(this.vy) > maxSpeed ? maxSpeed * Math.abs(this.vy) / this.vy : this.vy;
      this.oldx = this.x;
      this.oldy = this.y;
      this.x += this.vx;
      this.y += this.vy;
      this.vx = (0 < (ref = this.x) && ref < canvas.width + this.r * 2) ? this.vx : -this.vx;
      return this.vy = (0 < (ref1 = this.y) && ref1 < canvas.height + this.r * 2) ? this.vy : -this.vy;
    };

    Particle.prototype.attract = function() {
      var angle, bh, cx, cy, k, lax, lay, len, power, results;
      this.ax = this.ay = 0;
      results = [];
      for (k = 0, len = blackholes.length; k < len; k++) {
        bh = blackholes[k];
        cx = bh.x - this.x;
        cy = bh.y - this.y;
        angle = Math.atan(cx / cy);
        power = bh.power * 0.1;
        lax = Math.abs(power * Math.sin(angle));
        lay = Math.abs(power * Math.cos(angle));
        this.ax += cx > 0 ? lax : -lax;
        results.push(this.ay += cy > 0 ? lay : -lay);
      }
      return results;
    };

    Particle.prototype.draw = function() {
      bufferCtx.save();
      bufferCtx.strokeStyle = "#FFF";
      bufferCtx.lineCap = bufferCtx.lineJoin = "round";
      bufferCtx.lineWidth = this.r;
      bufferCtx.beginPath();
      bufferCtx.moveTo(this.oldx - this.r, this.oldy - this.r);
      bufferCtx.lineTo(this.x - this.r, this.y - this.r);
      bufferCtx.stroke();
      return bufferCtx.restore();
    };

    return Particle;

  })();

  BlackHole = (function() {
    function BlackHole(options) {
      this.x = options.x, this.y = options.y, this.r = options.r, this.power = options.power;
      this.step = 2;
      this.bigger = 5;
      this.animate(0);
    }

    BlackHole.prototype.draw = function(ctx) {
      var imgr;
      if (this.isAdd) {
        if ((this.ir += this.step) > (this.r + this.bigger)) {
          this.isAdd = false;
        }
      } else {
        this.ir = this.ir <= this.r ? this.r : this.ir - this.step;
        if (this.destory && this.ir === this.r) {
          blackholes.splice(blackholes.indexOf(this), 1);
        }
      }
      imgr = this.ir + bhImage.lightLen;
      return ctx.drawImage(bhImage, this.x - imgr, this.y - imgr, imgr * 2, imgr * 2);
    };

    BlackHole.prototype.animate = function(ir) {
      this.ir = ir;
      return this.isAdd = true;
    };

    BlackHole.prototype.check = function(bh) {
      var cr, cx, cy, nbh;
      if (!bh || !(bh instanceof BlackHole) || this.destory || bh.destory) {
        return false;
      }
      cx = Math.abs(bh.x - this.x);
      cy = Math.abs(bh.y - this.y);
      cr = bh.ir + this.ir;
      if (cx < cr && cy < cr && Math.sqrt(cx * cx + cy * cy) < cr) {
        nbh = new BlackHole({
          x: (bh.x + this.x) / 2,
          y: (bh.y + this.y) / 2,
          r: Math.max(bh.r, this.r) * 1.2,
          power: Math.max(bh.power, this.power) * 1.2
        });
        nbh.animate(Math.max(bh.r, this.r));
        if (nbh.r > 100) {
          this.destory = true;
        }
        blackholes.splice(blackholes.indexOf(this), 1);
        blackholes.splice(blackholes.indexOf(bh), 1);
        blackholes.push(nbh);
        return true;
      }
      return false;
    };

    return BlackHole;

  })();

  bhImage = (function() {
    var bhCas, bhCtx, i, k, lightLen, opacity;
    bhCas = document.createElement("canvas");
    bhCas.lightLen = lightLen = 5;
    bhCas.width = bhCas.height = (BH_SIZE + lightLen) * 2;
    bhCtx = bhCas.getContext("2d");
    opacity = 0;
    for (i = k = 0; k < 20; i = ++k) {
      opacity += 0.05;
      bhCtx.beginPath();
      bhCtx.fillStyle = "rgba(188,186,187," + opacity + ")";
      bhCtx.arc(bhCas.width / 2, bhCas.height / 2, BH_SIZE + lightLen - i, 0, Math.PI * 2);
      bhCtx.fill();
    }
    bhCtx.beginPath();
    bhCtx.fillStyle = "#000";
    bhCtx.arc(bhCas.width / 2, bhCas.height / 2, BH_SIZE, 0, Math.PI * 2);
    bhCtx.fill();
    return bhCas;
  })();

  target = null;

  canvas.onmousedown = function(e) {
    var bh, cx, cy, i, k, len, x, y;
    x = e.clientX - this.offsetLeft;
    y = e.clientY - this.offsetTop;
    for (i = k = 0, len = blackholes.length; k < len; i = ++k) {
      bh = blackholes[i];
      cx = bh.x - x;
      cy = bh.y - y;
      if (cx * cx + cy * cy <= bh.r * bh.r) {
        target = bh;
        break;
      }
    }
    if (!target && e.button === 0) {
      return blackholes.push(new BlackHole({
        x: x,
        y: y,
        r: BH_SIZE,
        power: 2
      }));
    } else if (e.button === 2) {
      return blackholes.splice(i, 1);
    }
  };

  canvas.onmousemove = function(e) {
    var x, y;
    if (target) {
      x = e.clientX - this.offsetLeft;
      y = e.clientY - this.offsetTop;
      target.x = x;
      return target.y = y;
    }
  };

  canvas.onmouseup = canvas.onmouseout = function(e) {
    return target = null;
  };

  execAnimate = function() {
    var i, k;
    for (i = k = 1; k < 200; i = ++k) {
      particles.push(new Particle({
        x: canvas.width * Math.random(),
        y: canvas.height * Math.random(),
        r: 2
      }));
    }
    return animate();
  };

  animate = function() {
    var bh, i, j, k, l, len, len1, m, p, ref, ref1;
    bufferCtx.save();
    bufferCtx.globalCompositeOperation = 'destination-out';
    bufferCtx.globalAlpha = 0.3;
    bufferCtx.fillRect(0, 0, canvas.width, canvas.height);
    bufferCtx.restore();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (i = k = 0, len = blackholes.length; k < len; i = ++k) {
      bh = blackholes[i];
      for (j = l = ref = i + 1, ref1 = blackholes.length; ref <= ref1 ? l < ref1 : l > ref1; j = ref <= ref1 ? ++l : --l) {
        if (bh && bh.check(blackholes[j])) {
          break;
        }
      }
      if (bh) {
        bh.draw(ctx);
      }
    }
    for (m = 0, len1 = particles.length; m < len1; m++) {
      p = particles[m];
      p.attract();
      p.move();
      p.draw();
    }
    ctx.drawImage(bufferCanvas, 0, 0);
    return RAF(animate);
  };

  execAnimate();

}).call(this);

//# sourceMappingURL=test.js.map
