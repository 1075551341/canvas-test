<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>LOW POLY（图片三角化）</title>
    <style>
        canvas{float:left;margin: 10px 0 0 30px;}
    </style>
</head>
<body>
<div>
    （请选取自己的图片文件）
    <input type="file" id="files" accept="image/*"/>
</div>

<canvas id="cas"></canvas>
<canvas id="cas2"></canvas>

<script src="sobel.js"></script>
<script src="delaunay.js"></script>
<script src="freestring.js"></script>
<script>
    var inputFile = document.getElementById("files");
    var canvas = document.getElementById("cas");
    var ctx = canvas.getContext("2d");

    var canvas_2 = document.getElementById("cas2");
    var ctx_2 = canvas_2.getContext("2d");

    var particle = [];

    var img = new Image();
    img.src = "./test.jpg";
    img.onload = function () {
        parse(this);
    };

    inputFile.onchange = function(){
        if(!this.files.length) return;

        var file = this.files[0];

        if (!/\/(?:jpeg|png)/i.test(file.type)) {
            alert("图片需为JPG或者PNG格式");
            return;
        }

        var reader = new FileReader();
        reader.onload = function(){
            var img = new Image();
            img.src = this.result;

            img.onload = function(){
                parse(this);
            }
        };
        reader.readAsDataURL(file);
    };

    function parse(img){
        canvas.width = canvas_2.width = (img.width > 800) ? 800 : img.width;
        canvas.height = canvas_2.height = img.height * canvas.width/img.width;

        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        var newImgData = Sobel(imgData);

        var collectors = [];
        var index;
//        收集亮度色值大于40的点
        for(var x=0;x<imgData.width;x++){
            for(var y=0;y<imgData.height;y++){
                index = ~~(y*imgData.width + x)*4;

                if(newImgData.data[index] > 40){
                    collectors.push([x , y]);
                }
            }
        }

//        对收集到的点随机排列
        collectors.sort(function(){return Math.random()-Math.random()});
        var size = ~~(collectors.length/50);
        particle = particle.concat(collectors.slice(0,size));
        particle = particle.concat([[0,0] , [0,canvas.height] , [canvas.width,0] , [canvas.width,canvas.height]]);

//        使用delaunay三角化获取三角坐标
        var triangles = Delaunay.triangulate(particle);

        var x1,x2,x3,y1,y2,y3,cx,cy;
        for(var i=0;i < triangles.length; i+=3) {
            x1 = particle[triangles[i]][0];
            x2 = particle[triangles[i+1]][0];
            x3 = particle[triangles[i+2]][0];
            y1 = particle[triangles[i]][1];
            y2 = particle[triangles[i+1]][1];
            y3 = particle[triangles[i+2]][1];

//            获取三角形中心点坐标
            cx = ~~((x1 + x2 + x3) / 3);
            cy = ~~((y1 + y2 + y3) / 3);

//            获取坐标的颜色值
            index = (cy*imgData.width + cx)*4;
            var color_r = imgData.data[index];
            var color_g = imgData.data[index+1];
            var color_b = imgData.data[index+2];

//            绘制三角形
            ctx_2.save();
            ctx_2.beginPath();
            ctx_2.moveTo(x1, y1);
            ctx_2.lineTo(x2, y2);
            ctx_2.lineTo(x3, y3);
            ctx_2.closePath();

            ctx_2.fillStyle = ctx_2.strokeStyle = "rgba("+color_r+","+color_g+","+color_b+",1)";
            ctx_2.fill();
            ctx_2.stroke();
            ctx_2.restore();
        }
    }
</script>
</body>
</html>