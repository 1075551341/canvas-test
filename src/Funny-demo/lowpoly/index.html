<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<canvas id="cas"></canvas>

<script src="delaunay.js"></script>
<script src="freestring.js"></script>
<script>
    var canvas = document.getElementById("cas");
    var ctx = canvas.getContext("2d");

    var count = 0;
    var particle = [];

    var img = new Image();
    img.src = "./test3.jpg";
    img.onload = function () {
        canvas.width = this.width;
        canvas.height = this.height;

        ctx.drawImage(this, 0, 0, canvas.width, canvas.height);

        while(count--){
            particle.push([Math.random()*canvas.width , Math.random()*canvas.height])
        }
        particle = particle.concat([[0,0] , [0,canvas.height] , [canvas.width,0] , [canvas.width,canvas.height]])

        var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        var kernel = [
            [ 1, 0,-1],
            [ 2, 0,-2],
            [ 1, 0,-1]
        ];
        var reducedImage = reduceColor(imgData);
        var collectors = [];
        var last = 0;
        var cout = 0;
        for(var x=0;x<canvas.width;x++){
            for(var y=0;y<canvas.height;y++){
                var index = ~~(y*imgData.width + x)*4;
                var value = Math.min(calcValue(x, y, kernel, reducedImage), 255);
//                imgData.data[index] = value;
//                imgData.data[index+1] = value;
//                imgData.data[index+2] = value;

                if(value > 180){
                    collectors.push([x , y]);
                }
            }
        }
//
//        ctx.putImageData(imgData , 0 , 0);
//        return;

        collectors.sort(function(){return Math.random()-Math.random()});
        particle = particle.concat(collectors.slice(0,10000));

        var triangles = Delaunay.triangulate(particle);
        var x1,x2,x3,y1,y2,y3,cx,cy;
        for(var i=0;i < triangles.length; i+=3) {
            x1 = particle[triangles[i]][0];
            x2 = particle[triangles[i+1]][0];
            x3 = particle[triangles[i+2]][0];
            y1 = particle[triangles[i]][1];
            y2 = particle[triangles[i+1]][1];
            y3 = particle[triangles[i+2]][1];

            cx = (x1+x2+x3)/3;
            cy = (y1+y2+y3)/3;

            var index = ~~(cy*imgData.width + cx)*4;
            var color_r = imgData.data[index];
            var color_g = imgData.data[index+1];
            var color_b = imgData.data[index+2];
            var color = freestring(function(){/*rgba(${0},${1},${2},1)*/},[color_r , color_g , color_b]);

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x3, y3);
            ctx.closePath();

            ctx.fillStyle = color;
            ctx.fill();

            ctx.restore();

//            break;
        }
    }

//    sobel边缘算法
    function reduceColor(imgData){
        var width = canvas.width;
        var height = canvas.height;

        var value , index;
        var table = new Array(width);
        for(var x=0;x<width;x++){
            table[x] = new Array(height);
            for(var y=0;y<height;y++){
                index = ~~(y*imgData.width + x)*4;
                value = Math.floor((imgData.data[index] + imgData.data[index + 1] + imgData.data[index + 2]) / 3);
                table[x][y] = value;
            }
        }

        return table;
    }

    function getReducedValue(x, y , rimage) {
        return (x < 0 || canvas.width <= x || y < 0 || canvas.height <= y) ? 0: rimage[x][y];
    }

    function calcValue(x, y , kernel , rimage) {
        var result = 0;
        for (var i = -1; i <= 1; i++) {
            for (var j = -1; j <= 1; j++) {
                result += kernel[i + 1][j + 1] * getReducedValue(x + i, y + j , rimage);
            }
        }
        return result;
    }

</script>
</body>
</html>